source "RMCreateArmPoints.mel";
source "RMCreateHandPoints.mel";
source "RMCreateHeadPoints.mel";
source "RMCreateSpinePoints.mel";
source "RMCreateLegPoints.mel";
source "RMNameConvention.mel";
source "RMRiggMath.mel";

global proc string[] CreateBipedCharacter (float $Size ,vector $FrontVector ,vector $UpVector){
    float $HeadSize = $Size/8;
    vector $TransversalVector = unit (cross ($FrontVector,$UpVector));
    float $HeadAndNeckSize = $HeadSize*1.2;
    float $LegSize = $HeadSize*4;
    float $ArmSize = $HeadSize*2.8;
    float $SpineSize = $HeadSize*2.8;
    
    string $SpineOrigin[] = RMCreateSpinePoints (<<0,$HeadSize*4,0>>,<<0,1,0>>,$SpineSize);
    
    string $NeckOrigin[] = RMCreateHeadRefPoints (<<0,$HeadSize*4+$SpineSize,0>>,<<0,1,0>>,<<0,0,-1>>, $HeadAndNeckSize);
    parent ($NeckOrigin[0]) ($SpineOrigin[(size($SpineOrigin)-1)]);

    string $ArmOriginRH[] = RMCreateArmPoints (<<0,$HeadSize*4+$SpineSize,0>>+($TransversalVector*$HeadSize), $TransversalVector, $ArmSize, "RH");
    string $ArmOriginLF[] = RMCreateArmPoints (<<0,$HeadSize*4+$SpineSize,0>>-($TransversalVector*$HeadSize), -$TransversalVector, $ArmSize, "LF");

    parent ($ArmOriginRH[0]) ($SpineOrigin[(size ($SpineOrigin))-1]);
    parent ($ArmOriginLF[0]) ($SpineOrigin[(size ($SpineOrigin))-1]);

    //select -r $SpineOrigin[0];
    vector $temp = <<0,($HeadSize*4),0>>;
    string $LegOriginRH[] = RMCreateLegPoints (($temp+$TransversalVector*$HeadSize/2), $UpVector*(-1), $FrontVector, $LegSize, "RH");
    string $LegOriginLF[] = RMCreateLegPoints (($temp-$TransversalVector*$HeadSize/2), $UpVector*(-1), $FrontVector, $LegSize, "LF");

    parent ($LegOriginLF[0]) ($SpineOrigin[(size ($SpineOrigin))-1]);
    parent ($LegOriginRH[0]) ($SpineOrigin[(size ($SpineOrigin))-1]);
/**/
    return ($SpineOrigin);
}

global proc RMSymTransform (string $Obj01[], string $Obj02[]){
    select -r ($Obj01[0]);

    vector $Obj01Position=`xform -q -translation`;
    //print $Obj01Position;
    vector $tempVect = <<-$Obj01Position.x,$Obj01Position.y,$Obj01Position.z>>;
    $Obj01Position=$tempVect;
    
    //vector $Obj01Rotation=ReturnParentRotation($Obj01);
    select -r ($Obj01[0]);
    vector $Obj01Rotation=`xform -q -rotation`;
    
    select -r $Obj02;
    //vector $Obj02Rotation = ReturnParentRotation($Obj02);
    vector $Obj02Rotation= <<($Obj01Rotation.x*(1)),($Obj01Rotation.y*(-1)),($Obj01Rotation.z*(-1))>>;
    
    select -r $Obj02[0];
    //string $temp[] = `listRelatives -p`;
    //select -r $temp[0];
    //move ($Obj01Position.x) ($Obj01Position.y) ($Obj01Position.z);
    setAttr ($Obj02[0]+".translate") -type "double3" ($Obj01Position.x) ($Obj01Position.y) ($Obj01Position.z);
    setAttr ($Obj02[0]+".rotate") -type "double3" ($Obj02Rotation.x) ($Obj02Rotation.y) ($Obj02Rotation.z);
    
}
global proc int RMIgnoraShape (string $name)
{
    
    if (RMGetFromName($name,4)=="rfrShape")
    {
        return false;
    }
    else 
    {
        if (RMGetFromName($name,5)=="rfrShape")
        {
            return false;
        }
    }
    return true;
}
global proc RMMirrorPositionPoints(){
    string $temp[] = `ls -sl`;
    string $temp2[] = `listRelatives -ad`;
    $temp2[`size $temp2`]=$temp[0];
    string $temp3[] = ReverseArray($temp2);
    
    string $objID="";
    string $objSide1[]={};
    string $objOpositeSide[]={};
    for ($i in $temp2){
        $objSide1[0]=$i;
             // print $i;
        if (RMIgnoraShape($objSide1[0])==true)
        {
            if (RMGetFromName($objSide1[0],1) == "LF" )
            {
               
                string $Obj=RMSetFromName ($objSide1[0],1,("RH"));
                //print $Obj;
                $objOpositeSide[0]=$Obj;
                RMSymTransform ($objSide1, $objOpositeSide);
                
            }
            else 
            {
                
                if (RMGetFromName($objSide1[0],1) == "RH" )
                {
                    string $Obj=RMSetFromName ($objSide1[0],1,("LF"));
                    //$objOpositeSide=`select -r $Obj`;
                    $objOpositeSide[0]=$Obj;
                    RMSymTransform ($objSide1, $objOpositeSide);
    
                }
                else 
                {
                    print (("No OpositeSide for object ")+ ($objSide1[0]));
                }
            }
        }
    }
}
