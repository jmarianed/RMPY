source "RMRigFunctions.mel";
source "RMRigShapeControls.mel";
source "RMRiggTools.mel";
source "RMRigFK.mel";
source "RMNameConvention.mel";

global proc RMIKCreateonSelected()
{
	string $temp []=`ls -sl`;
	string $BonesS[]=`RMCreateBonesAtPoints $temp`;
	RMCreateIKControls $BonesS[0] 50;
}

proc string[] RMCreatePoleVector (string $IKHandle)
{
    //Obtiene el inicio y fin del IKHandle
    string $startJoint=`ikHandle -q -sj $IKHandle`;
    string $endJoint=`ikHandle -q -ee $IKHandle`;
    //Selecciona el segundo joint del IK
    select -r $startJoint;
    string $temp[]=`pickWalk -d "down"`;
    string $forearm=$temp[0];
    //Crea un locator lo posiciona en la segundo joint crea en el un aim
    //constraint que apunta al inicio del IK y su up vector es el final del IK
    
    string $locator = RMGetPoleVectorPoint ({$startJoint,$forearm,$endJoint});
/*  string $temp1[]=`spaceLocator`;
    string $locator=$temp1[0];
    string $temp1[]=`spaceLocator`;
    string $locator2=$temp1[0];
    alinea $forearm $locator2 3;
    float $LongitudDeHueso=`LenghtOfBone $forearm`;
    move -r -os -moveXYZ ($LongitudDeHueso/2) 0 0 $locator2;
    alinea $locator2 $locator 1;
    delete $locator2;
    aimConstraint -wut "object" $startJoint $endJoint $locator;
*/  float $RMDistancia = `RMDistancia $startJoint $endJoint`;
    //move -r -os -moveX (-$RMDistancia/3*2) 0 0 $locator;
    
    
    string $CntrlName = $IKHandle;
    $CntrlName=`RMSetFromName $CntrlName 3 "ctr"`;
    $CntrlName=`RMSetFromName $CntrlName 4 "rig"`;
    $CntrlName=`RMAddToName $CntrlName "PoleVector"`;
    $CntrlName=`RMUniqueName $CntrlName`;
    //////////////////////////////////////////////////////////////////7
    //Crea el Cntrl, donde Cntrl Tiene los el cubo del Pole Vector
    $Cntrl=`RMCreateCubeLine ($RMDistancia/10) ($RMDistancia/10) ($RMDistancia/10) $CntrlName`;
    
    move -r ($RMDistancia/20) 0 0 ($Cntrl+".scalePivot") ($Cntrl+".rotatePivot");
    move -rpr -a 0 0 0 $Cntrl;
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $CntrlName;
    string $LineCntrls[]=`RMCreateLineBetwenPoints $Cntrl $temp[0]`;
    
    RMAlign $locator $CntrlName 1;
    delete $locator;
    ikHandle -e -sol "ikRPsolver" $IKHandle;
    string $poleVectorName=$IKHandle;
    $poleVectorName=`RMSetFromName $poleVectorName 3 "pvc"`;
    poleVectorConstraint -name $poleVectorName $CntrlName $IKHandle;
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $CntrlName;

    parent $LineCntrls[0] NoScaledData;
    parent $Cntrl ScaledData;
    return ({string ($Cntrl),string($LineCntrls[0])});
}

/*Funcion que agrega un Pole Vector a el Objeto y crea un cubo y una linea que va de el hueso medio al cubo*/
global proc string RMGetPoleVectorPoint (string $BoneArray[]){
  vector $P1=`xform -a -ws -q -rp $BoneArray[0]`;
  vector $P2=`xform -a -ws -q -rp $BoneArray[1]`;
  vector $P3=`xform -a -ws -q -rp $BoneArray[2]`;
  vector $V1=$P2-$P1;
  vector $V2=$P3-$P2;
//the vector turned in to an array to the cross product operation
  float $V1a[]={$V1.x,$V1.y,$V1.z};
  float $V2a[]={$V2.x,$V2.y,$V2.z};
  float $Angulo=angle($V1,$V2);
  float $Angulo3=((rad_to_deg($Angulo)+180)/2);
  float $Angulo=deg_to_rad($Angulo3-90);
  float $EjeZ[]= crossProduct ($V1a,$V2a,1,1);
  float $EjeY[]= crossProduct ($V2a,$EjeZ,1,1);  
  float $EjeX[]= $V2a;
  normalize $EjeX;
  float $Y1=cos ($Angulo);
  float $X1= - sin($Angulo);
  float $Vy[]={$EjeY[0]*$Y1,$EjeY[1]*$Y1,$EjeY[2]*$Y1};
  float $Vx[]={$EjeX[0]*$X1,$EjeX[1]*$X1,$EjeX[2]*$X1};
  float $LProm=(mag ($V1) + mag ($V2))/2;//Longitud promedio
  float $Vres[]={($Vy[0]+$Vx[0])*$LProm,($Vy[1]+$Vx[1])*$LProm,($Vy[2]+$Vx[2])*$LProm};
  vector $PoleVector = <<$Vres[0]+$P2.x,$Vres[1]+$P2.y,$Vres[2]+$P2.z>>;
    string $temp1[]=`spaceLocator`;
    string $locator=$temp1[0];
  xform -ws -t ($PoleVector.x) ($PoleVector.y) ($PoleVector.z)  $locator;
  return $locator;
}
global proc string[] RMCreateIKControls (string $IKroot,int $depth)
{
    string $Ex1=$IKroot;
    string $Childs[];
    int $Index=0;
    float $Tam;
    string $CntrlExt[];
    string $GrupoCntrl[];
    $Childs=`listRelatives -c $Ex1`;
    
    string $Ex2;
    $Tam=`size $Childs`;
    float $Lenghtbone;
    while (($Tam!=0)&&($Index!=$depth))
    {
        
        $Ex2=$Childs[0];
        $Lenghtbone = `RMLenghtOfBone $Ex2`/3;
        
        $Childs=`listRelatives -c $Ex2`;
        $Tam=`size $Childs`;
        $Index=$Index+1;
    }
    
    string $IKname=$Ex2;
    $IKname=`RMSetFromName $IKname 3 "IKH"`;
    $IKname=`RMSetFromName $IKname 4 "IK"`;
    string $BallIK=`RMSetFromName $IKname 2 "BallIK"`;
    string $TipIK=`RMSetFromName $IKname 2 "TipIK"`;
    ikHandle -sj $Ex1 -ee $Ex2 -name $IKname;

    string $IKcontrol=`RMSetFromName $Ex2 3 "ctr"`;
    $IKcontrol=`RMUniqueName $IKcontrol`;
    $IKcontrol = `RMCreateCubeLine $Lenghtbone $Lenghtbone $Lenghtbone $IKcontrol`;
    move -r ($Lenghtbone/2) 0 0 ($IKcontrol+".scalePivot") ($IKcontrol+".rotatePivot");
    move -rpr -a 0 0 0 $IKcontrol;
    makeIdentity -apply true -t 1 -r 1 -s 1 -n 0 $IKcontrol;
    RMAlign $Ex2 $IKcontrol 1;

    string $PoleVector[]=`RMCreatePoleVector $IKname`;
    RMMakeIkStretchy $IKname;
    RMMakeIkStretchy $IKname;
    pointConstraint $IKcontrol $IKname;

    return ({$IKcontrol,$PoleVector[0],$PoleVector[1]});
}


